<!DOCTYPE html>
<html lang="en">
  <head>
    <title>dbks - Go's Missing Functional Suspects</title>
   	<meta name="description" content="Go's Missing Functional Suspects" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta content="utf-8" http-equiv="encoding" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/github.min.css" />
    <link rel="stylesheet" href="/s/style.css" />
  </head>
  <body>
    <div id="title">
      <a href="/"><img alt="dbks logo" src="/i/dbks.png" /></a> <a href="/"><h1>deathbykeystroke</h1></a>
    </div>
    <div id="article">
      <h1>Go's Missing Functional Suspects</h1>
      <h6>// date:  2021-11-12</h6>
      <h6>// filed: <a href="/tags/golang.html">golang</a>, <a href="/tags/programming.html">programming</a></h6>
      <h6>// <a href="https://deathbykeystroke.com/articles/20211112-gos-missing-functional-suspects.html">perma</a></h6>
      <br/>

      <p>When you first start learning functional programming you get all kinds of tools that challenge how you think about lists. You get things like <code>foldl</code>, <code>foldr</code>, <code>map</code>, and <code>filter</code>. Those things are really hard to stop using because they're <em>very</em> concise and clear in the way they function. Let's make a golang generator that gives us those four functions for any type in go!</p>
<h2 id="writing-a-generator">Writing a Generator</h2>
<p>Go could have macros but it doesn't because there's no precompiler. Instead of a precompiler they wrote code that does what macros do but you have to run it manually before you run your code rather than just inlining during compilation. So let's write a generator that just spits out a random number and then we'll modify it later so that it gives us what we want function wise.</p>
<p>In your scratch pad project directory toss the following into a file (<code>pkg/generators/functional.go</code>):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb1-1" title="1"><span class="co">//go:build ignore</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">package</span> main</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb1-6" title="6">        <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb1-7" title="7">        <span class="st">&quot;math/rand&quot;</span></a>
<a class="sourceLine" id="cb1-8" title="8">        <span class="st">&quot;os&quot;</span></a>
<a class="sourceLine" id="cb1-9" title="9">        <span class="st">&quot;text/template&quot;</span></a>
<a class="sourceLine" id="cb1-10" title="10">        <span class="st">&quot;time&quot;</span></a>
<a class="sourceLine" id="cb1-11" title="11">)</a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="kw">var</span> genTemplate = <span class="st">`// Code generated by go; DO NOT EDIT.</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="st">// Generated {{ .Timestamp }}</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="st">package main</span></a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="st">import &quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="st">func main() {</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="st">  fmt.Printf(&quot;%d</span><span class="ch">\n</span><span class="st">&quot;, {{.Random}})</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="st">}</span></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="st">`</span></a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="kw">func</span> main() {</a>
<a class="sourceLine" id="cb1-25" title="25">        file, err := os.Create(<span class="st">&quot;main_random.go&quot;</span>)</a>
<a class="sourceLine" id="cb1-26" title="26">        <span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb1-27" title="27">                fmt.Errorf(<span class="st">&quot;%v&quot;</span>, err)</a>
<a class="sourceLine" id="cb1-28" title="28">                os.Exit(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-29" title="29">        }</a>
<a class="sourceLine" id="cb1-30" title="30">        <span class="kw">defer</span> file.Close()</a>
<a class="sourceLine" id="cb1-31" title="31"></a>
<a class="sourceLine" id="cb1-32" title="32">        template.Must(template.New(<span class="st">&quot;&quot;</span>).Parse(genTemplate)).Execute(file, <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb1-33" title="33">                Random    <span class="dt">uint64</span></a>
<a class="sourceLine" id="cb1-34" title="34">                Timestamp time.Time</a>
<a class="sourceLine" id="cb1-35" title="35">        }{</a>
<a class="sourceLine" id="cb1-36" title="36">                rand.Uint64(),</a>
<a class="sourceLine" id="cb1-37" title="37">                time.Now(),</a>
<a class="sourceLine" id="cb1-38" title="38">        })</a>
<a class="sourceLine" id="cb1-39" title="39">}</a></code></pre></div>
<p>What a mouthful. Don't worry, this should make what we're about to do much easier. This generator will get modified later. You can test it manually by doing a quick <code>go run pkg/generators/functional.go &amp;&amp; go run main_random.go</code> and you can clean it up by just removing the generated <code>main_random.go</code> file.</p>
<p>I'm going to put this generator in <code>pkg/generators</code> directory to refer to later so we have this directory structure for the demo:</p>
<pre><code>.
├── app.go
├── go.mod
└── pkg
    └─── generators
         └── functional.go</code></pre>
<h2 id="demo-structs">Demo Structs</h2>
<p>Now let's make a demo struct we can do something functional with. In <code>pkg/mytypes/demo.go</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">package</span> mytypes</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">//go:generate go run ../generators/functional.go Demo string int</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">type</span> Demo <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb3-6" title="6">        Str <span class="dt">string</span></a>
<a class="sourceLine" id="cb3-7" title="7">        Num <span class="dt">int</span></a>
<a class="sourceLine" id="cb3-8" title="8">}</a></code></pre></div>
<p>Now if you run <code>go generate pkg/mytypes/demo.go</code> you'll actually see a new file <code>main_random.go</code> that will still just spit out a random number. Let's fix that to do a filter.</p>
<h2 id="implementing-filter">Implementing Filter</h2>
<p>Focusing on <code>pkg/generators/functional.go</code> and modify a few things. First, the package needs to be fixed so change that the template does something more in the spirit of functional programming (make this more practical if you're following this for real world stuff). Let's enhance our generator to loop over arguments and use those. Our generator should now look something like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb4-1" title="1"><span class="co">//go:build ignore</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">package</span> main</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">import</span> (</a>
<a class="sourceLine" id="cb4-6" title="6">        <span class="st">&quot;fmt&quot;</span></a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="st">&quot;os&quot;</span></a>
<a class="sourceLine" id="cb4-8" title="8">        <span class="st">&quot;strings&quot;</span></a>
<a class="sourceLine" id="cb4-9" title="9">        <span class="st">&quot;text/template&quot;</span></a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="st">&quot;time&quot;</span></a>
<a class="sourceLine" id="cb4-11" title="11">)</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="kw">var</span> genTemplate = <span class="st">`{{- $m := . -}}</span></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="st">// Code generated by go; DO NOT EDIT.</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="st">// Generated {{ $m.Timestamp }}</span></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="st">// Functional receivers for {{ $m.Receiver }}</span></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="st">// With types {{ $m.Types }}</span></a>
<a class="sourceLine" id="cb4-18" title="18"></a>
<a class="sourceLine" id="cb4-19" title="19"><span class="st">package {{ $m.Package }}</span></a>
<a class="sourceLine" id="cb4-20" title="20"><span class="st">`</span></a>
<a class="sourceLine" id="cb4-21" title="21"></a>
<a class="sourceLine" id="cb4-22" title="22"><span class="kw">func</span> gen(pkg, name <span class="dt">string</span>, types []<span class="dt">string</span>) <span class="dt">error</span> {</a>
<a class="sourceLine" id="cb4-23" title="23">        file, err := os.Create(fmt.Sprintf(<span class="st">&quot;%s_fns.go&quot;</span>, strings.ToLower(name)))</a>
<a class="sourceLine" id="cb4-24" title="24">        <span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb4-25" title="25">                <span class="kw">return</span> err</a>
<a class="sourceLine" id="cb4-26" title="26">        }</a>
<a class="sourceLine" id="cb4-27" title="27">        <span class="kw">defer</span> file.Close()</a>
<a class="sourceLine" id="cb4-28" title="28"></a>
<a class="sourceLine" id="cb4-29" title="29">        funcs := template.FuncMap{</a>
<a class="sourceLine" id="cb4-30" title="30">                <span class="st">&quot;Title&quot;</span>: strings.Title,</a>
<a class="sourceLine" id="cb4-31" title="31">        }</a>
<a class="sourceLine" id="cb4-32" title="32"></a>
<a class="sourceLine" id="cb4-33" title="33">        template.Must(template.New(<span class="st">&quot;&quot;</span>).Funcs(funcs).Parse(genTemplate)).Execute(file, <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb4-34" title="34">                Package   <span class="dt">string</span></a>
<a class="sourceLine" id="cb4-35" title="35">                Receiver  <span class="dt">string</span></a>
<a class="sourceLine" id="cb4-36" title="36">                Alias     <span class="dt">string</span></a>
<a class="sourceLine" id="cb4-37" title="37">                Types     []<span class="dt">string</span></a>
<a class="sourceLine" id="cb4-38" title="38">                Timestamp time.Time</a>
<a class="sourceLine" id="cb4-39" title="39">        }{</a>
<a class="sourceLine" id="cb4-40" title="40">                pkg,</a>
<a class="sourceLine" id="cb4-41" title="41">                name,</a>
<a class="sourceLine" id="cb4-42" title="42">                fmt.Sprintf(<span class="st">&quot;%ss&quot;</span>, name),</a>
<a class="sourceLine" id="cb4-43" title="43">                types,</a>
<a class="sourceLine" id="cb4-44" title="44">                time.Now(),</a>
<a class="sourceLine" id="cb4-45" title="45">        })</a>
<a class="sourceLine" id="cb4-46" title="46">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb4-47" title="47">}</a>
<a class="sourceLine" id="cb4-48" title="48"></a>
<a class="sourceLine" id="cb4-49" title="49"><span class="kw">func</span> main() {</a>
<a class="sourceLine" id="cb4-50" title="50">        <span class="kw">if</span> err := gen(os.Args[<span class="dv">1</span>], os.Args[<span class="dv">2</span>], os.Args[<span class="dv">3</span>:]); err != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb4-51" title="51">                fmt.Fprintf(os.Stderr, <span class="st">&quot;error generating %s: %v</span><span class="ch">\n</span><span class="st">&quot;</span>, os.Args[<span class="dv">1</span>], err)</a>
<a class="sourceLine" id="cb4-52" title="52">        }</a>
<a class="sourceLine" id="cb4-53" title="53">}</a></code></pre></div>
<p>and after <code>go generate pkg/mytypes/demo.go</code> our directory should be:</p>
<pre><code>.
├── app.go
├── go.mod
└── pkg
    ├── generators
    │   └── functional.go
    └── mytypes
        ├── demo_fns.go
        └── demo.go
</code></pre>
<p>In the main function of the generator we're gather arguments and giving them to the generator one by one. The line checking for a lowercase first letter is the gatherer. It's not going to get any use for <code>filter</code> but we will need it for <code>map</code> because it takes one type and doesn't necessarily return that type.</p>
<p>Now we're pretty much set for life. Time to retire. Unless you're having fun then let's do some filtering. From here it's just straight go.</p>
<p>Our filter function should look something like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">type</span> AS []A</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">func</span> (xs As) Filter(fn <span class="kw">func</span>(A) <span class="dt">bool</span>) []A {</a>
<a class="sourceLine" id="cb6-4" title="4">    rs := <span class="bu">make</span>([]A, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="kw">for</span> _, x := <span class="kw">range</span> xs {</a>
<a class="sourceLine" id="cb6-6" title="6">        <span class="kw">if</span> fn(x) {</a>
<a class="sourceLine" id="cb6-7" title="7">            rs = <span class="bu">append</span>(rs, x)</a>
<a class="sourceLine" id="cb6-8" title="8">        }</a>
<a class="sourceLine" id="cb6-9" title="9">    }</a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="kw">return</span> rs</a>
<a class="sourceLine" id="cb6-11" title="11">}</a></code></pre></div>
<p>And we can template-ize that as:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">type</span> {{ $m.Alias }} []{{ $m.Receiver }}</a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">func</span> (xs {{ $m.Alias }}) Filter(fn <span class="kw">func</span>({{ $m.Receiver }}) <span class="dt">bool</span>) []{{ $m.Receiver }} {</a>
<a class="sourceLine" id="cb7-4" title="4">        rs := <span class="bu">make</span>([]{{ $m.Receiver }}, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb7-5" title="5">        <span class="kw">for</span> _, x := <span class="kw">range</span> xs {</a>
<a class="sourceLine" id="cb7-6" title="6">                <span class="kw">if</span> fn(x) {</a>
<a class="sourceLine" id="cb7-7" title="7">                        rs = <span class="bu">append</span>(rs, x)</a>
<a class="sourceLine" id="cb7-8" title="8">                }</a>
<a class="sourceLine" id="cb7-9" title="9">        }</a>
<a class="sourceLine" id="cb7-10" title="10">        <span class="kw">return</span> rs</a>
<a class="sourceLine" id="cb7-11" title="11">}</a></code></pre></div>
<p>So now when you run your generate statement you should get the following in <code>pkg/mytypes/demo_fns.go</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb8-1" title="1"><span class="co">// Code generated by go; DO NOT EDIT.</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="co">// Generated 2021-11-12 16:28:41.742174392 -0800 PST m=+0.000470763</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">// Functional receivers for Demo</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="co">// With types [string int]</span></a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">package</span> mytypes</a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="kw">type</span> Demos []Demo</a>
<a class="sourceLine" id="cb8-9" title="9"></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="kw">func</span> (xs Demos) Filter(fn <span class="kw">func</span>(Demo) <span class="dt">bool</span>) []Demo {</a>
<a class="sourceLine" id="cb8-11" title="11">        rs := <span class="bu">make</span>([]Demo, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb8-12" title="12">        <span class="kw">for</span> _, x := <span class="kw">range</span> xs {</a>
<a class="sourceLine" id="cb8-13" title="13">                <span class="kw">if</span> fn(x) {</a>
<a class="sourceLine" id="cb8-14" title="14">                        rs = <span class="bu">append</span>(rs, x)</a>
<a class="sourceLine" id="cb8-15" title="15">                }</a>
<a class="sourceLine" id="cb8-16" title="16">        }</a>
<a class="sourceLine" id="cb8-17" title="17">        <span class="kw">return</span> rs</a>
<a class="sourceLine" id="cb8-18" title="18">}</a></code></pre></div>
<p>Now, wherever <code>Demo</code>s are used you can do a quick <code>demos.Filter(func (d Demo) { return d.Num &gt; 3 })</code> to get all of your objects where the number is greater than three. In your own version you might even change the return type so that <code>.Filter</code> becomes chainable with some other stuff down the line.</p>
<h3 id="map">Map</h3>
<p>Map gets a little sticky. The return type is usually known to the programmer but go's compiler needs to know. This is where all that wonky stuff we did in the generator's <code>main</code> comes in handy. We can tell our generator what it is we <em>really</em> need from a <code>Map</code>.</p>
<p>Our ideal <code>Map</code> might look something like:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">func</span> (xs Demos) MapString(fn <span class="kw">func</span>(Demo) <span class="dt">string</span>) []<span class="dt">string</span> {</a>
<a class="sourceLine" id="cb9-2" title="2">    rs := <span class="bu">make</span>([]<span class="dt">string</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">for</span> _, x := <span class="kw">range</span> xs {</a>
<a class="sourceLine" id="cb9-4" title="4">        rs = <span class="bu">append</span>(rs, fn(x))</a>
<a class="sourceLine" id="cb9-5" title="5">    }</a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="kw">return</span> rs</a>
<a class="sourceLine" id="cb9-7" title="7">}</a></code></pre></div>
<p>Jeez, what a beaut.</p>
<p>To template that we need to be able to loop over whatever types were requested of the generator and to do that we can use some template magic:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb10-1" title="1">{{- <span class="kw">range</span> $t := $m.Types }}</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">func</span> (xs {{ $m.Alias }}) Map{{ $t | Title }}(fn <span class="kw">func</span>({{ $m.Receiver }}) {{ $t }}) []{{ $t }} {</a>
<a class="sourceLine" id="cb10-3" title="3">        rs := <span class="bu">make</span>([]{{ $t }}, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb10-4" title="4">        <span class="kw">for</span> _, x := <span class="kw">range</span> xs {</a>
<a class="sourceLine" id="cb10-5" title="5">                rs = <span class="bu">append</span>(rs, fn(x))</a>
<a class="sourceLine" id="cb10-6" title="6">        }</a>
<a class="sourceLine" id="cb10-7" title="7">        <span class="kw">return</span> rs</a>
<a class="sourceLine" id="cb10-8" title="8">}</a>
<a class="sourceLine" id="cb10-9" title="9">{{- end }}</a></code></pre></div>
<p>This loops over the types our main parsed and generates <code>MapString</code> and <code>MapInt</code>. If you need others you can always go back to your <code>pkg/mytypes/demo.go</code> file and add the types to your <code>go:generate</code> line. Now when you generate you'll have two more functions in your package.</p>
<p>So now we have <code>filter</code> and <code>map</code>. Lastly we need some fold equivalents and we'll generate those in the <code>mytypes</code> package simply because this is a demo and you shouldn't be copy and pasting code blindly into your editor.</p>
<h2 id="implementing-folds">Implementing Folds</h2>
<p>So, create another generator file called <code>pkg/generators/folds.go</code> and let's modify functions <code>main</code> and <code>gen</code> to look like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">func</span> gen(pkg <span class="dt">string</span>, pairs [][]<span class="dt">string</span>) <span class="dt">error</span> {</a>
<a class="sourceLine" id="cb11-2" title="2">        file, err := os.Create(fmt.Sprintf(<span class="st">&quot;%s_folds.go&quot;</span>, strings.ToLower(pkg)))</a>
<a class="sourceLine" id="cb11-3" title="3">        <span class="kw">if</span> err != <span class="ot">nil</span> {</a>
<a class="sourceLine" id="cb11-4" title="4">                <span class="kw">return</span> err</a>
<a class="sourceLine" id="cb11-5" title="5">        }</a>
<a class="sourceLine" id="cb11-6" title="6">        <span class="kw">defer</span> file.Close()</a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8">        funcs := template.FuncMap{</a>
<a class="sourceLine" id="cb11-9" title="9">                <span class="st">&quot;Title&quot;</span>: strings.Title,</a>
<a class="sourceLine" id="cb11-10" title="10">        }</a>
<a class="sourceLine" id="cb11-11" title="11"></a>
<a class="sourceLine" id="cb11-12" title="12">        template.Must(template.New(<span class="st">&quot;&quot;</span>).Funcs(funcs).Parse(genTemplate)).Execute(file, <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb11-13" title="13">                Package   <span class="dt">string</span></a>
<a class="sourceLine" id="cb11-14" title="14">                Pairs     [][]<span class="dt">string</span></a>
<a class="sourceLine" id="cb11-15" title="15">                Timestamp time.Time</a>
<a class="sourceLine" id="cb11-16" title="16">        }{</a>
<a class="sourceLine" id="cb11-17" title="17">                pkg,</a>
<a class="sourceLine" id="cb11-18" title="18">                pairs,</a>
<a class="sourceLine" id="cb11-19" title="19">                time.Now(),</a>
<a class="sourceLine" id="cb11-20" title="20">        })</a>
<a class="sourceLine" id="cb11-21" title="21">        <span class="kw">return</span> <span class="ot">nil</span></a>
<a class="sourceLine" id="cb11-22" title="22">}</a>
<a class="sourceLine" id="cb11-23" title="23"></a>
<a class="sourceLine" id="cb11-24" title="24"><span class="kw">func</span> main() {</a>
<a class="sourceLine" id="cb11-25" title="25">        pkg := os.Args[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb11-26" title="26">        pairs := [][]<span class="dt">string</span>{}</a>
<a class="sourceLine" id="cb11-27" title="27">        <span class="kw">for</span> idx := <span class="dv">2</span>; idx &lt; <span class="bu">len</span>(os.Args); idx += <span class="dv">2</span> {</a>
<a class="sourceLine" id="cb11-28" title="28">                pairs = <span class="bu">append</span>(pairs, os.Args[idx:idx+<span class="dv">2</span>])</a>
<a class="sourceLine" id="cb11-29" title="29">        }</a>
<a class="sourceLine" id="cb11-30" title="30">        gen(pkg, pairs)</a>
<a class="sourceLine" id="cb11-31" title="31">}</a></code></pre></div>
<p>Our fold generator is going to take a list of type pairs we need folds for and generate those. So if we give the generator <code>string int</code> we'll get folds where our accumulator and inputs are of types <code>string int</code> respectively.</p>
<p>In our template we'll modify the non boilerplate comments with the following bit of cuteness:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb12-1" title="1">{{ <span class="kw">range</span> $t := $m.Pairs }}</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">func</span> Foldl{{ index $t <span class="dv">0</span> | Title }}{{ index $t <span class="dv">1</span> | Title }}(fn <span class="kw">func</span>(a {{ index $t <span class="dv">0</span> }}, b {{ index $t <span class="dv">1</span> }}) {{ index $t <span class="dv">0</span> }}, acc {{ index $t <span class="dv">0</span> }}, is []{{ index $t <span class="dv">1</span> }}) {{ index $t <span class="dv">0</span> }} {</a>
<a class="sourceLine" id="cb12-3" title="3">        res := acc</a>
<a class="sourceLine" id="cb12-4" title="4">        <span class="kw">for</span> i := <span class="kw">range</span> is {</a>
<a class="sourceLine" id="cb12-5" title="5">                res = fn(res, <span class="bu">len</span>(is) - <span class="dv">1</span> - i)</a>
<a class="sourceLine" id="cb12-6" title="6">        }</a>
<a class="sourceLine" id="cb12-7" title="7">        <span class="kw">return</span> res</a>
<a class="sourceLine" id="cb12-8" title="8">}</a>
<a class="sourceLine" id="cb12-9" title="9"></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="kw">func</span> Foldr{{ index $t <span class="dv">0</span> | Title }}{{ index $t <span class="dv">1</span> | Title }}(fn <span class="kw">func</span>(a {{ index $t <span class="dv">0</span> }}, b <span class="kw">func</span>() {{ index $t <span class="dv">1</span> }}) {{ index $t <span class="dv">0</span> }}, acc {{ index $t <span class="dv">0</span> }}, is []{{ index $t <span class="dv">1</span> }}) {{ index $t <span class="dv">0</span> }} {</a>
<a class="sourceLine" id="cb12-11" title="11">        res := acc</a>
<a class="sourceLine" id="cb12-12" title="12">        <span class="kw">for</span> idx := <span class="dv">0</span>; idx &lt; <span class="bu">len</span>(is); idx++ {</a>
<a class="sourceLine" id="cb12-13" title="13">                called := <span class="ot">false</span></a>
<a class="sourceLine" id="cb12-14" title="14">                lambda := <span class="kw">func</span>() {{ index $t <span class="dv">1</span> }} {</a>
<a class="sourceLine" id="cb12-15" title="15">                        called = <span class="ot">true</span></a>
<a class="sourceLine" id="cb12-16" title="16">                        <span class="kw">return</span> is[idx]</a>
<a class="sourceLine" id="cb12-17" title="17">                }</a>
<a class="sourceLine" id="cb12-18" title="18">                res = fn(res, lambda)</a>
<a class="sourceLine" id="cb12-19" title="19">                <span class="kw">if</span> !called {</a>
<a class="sourceLine" id="cb12-20" title="20">                        <span class="kw">return</span> res</a>
<a class="sourceLine" id="cb12-21" title="21">                }</a>
<a class="sourceLine" id="cb12-22" title="22">        }</a>
<a class="sourceLine" id="cb12-23" title="23">        <span class="kw">return</span> res</a>
<a class="sourceLine" id="cb12-24" title="24">}</a>
<a class="sourceLine" id="cb12-25" title="25">{{- end }}</a></code></pre></div>
<p>With the input tuple <code>string, int</code> this template will generate <code>FoldlStringInt</code> and <code>FoldrStringInt</code>. Now we're having some real fun.</p>
<p>Now we can add <code>//go:generate go run ../generators/folds.go mytypes int int</code> to <code>pkg/mytypes/demo.go</code>, run the generator, and then you can view the very excellent generated code in <code>pkg/mytypes/mytypes_folds.go</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode go"><code class="sourceCode go"><a class="sourceLine" id="cb13-1" title="1"><span class="co">// Code generated by go; DO NOT EDIT.</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="co">// Generated 2021-11-12 16:52:05.48205752 -0800 PST m=+0.000807965</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co">// Functional folds for mytypes</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="co">// Pairs:</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="co">// int - int</span></a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="kw">package</span> mytypes</a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9"></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="kw">func</span> FoldlIntInt(fn <span class="kw">func</span>(a <span class="dt">int</span>, b <span class="dt">int</span>) <span class="dt">int</span>, acc <span class="dt">int</span>, is []<span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb13-11" title="11">        res := acc</a>
<a class="sourceLine" id="cb13-12" title="12">        <span class="kw">for</span> i := <span class="kw">range</span> is {</a>
<a class="sourceLine" id="cb13-13" title="13">                res = fn(res, <span class="bu">len</span>(is) - <span class="dv">1</span> - i)</a>
<a class="sourceLine" id="cb13-14" title="14">        }</a>
<a class="sourceLine" id="cb13-15" title="15">        <span class="kw">return</span> res</a>
<a class="sourceLine" id="cb13-16" title="16">}</a>
<a class="sourceLine" id="cb13-17" title="17"></a>
<a class="sourceLine" id="cb13-18" title="18"><span class="kw">func</span> FoldrIntInt(fn <span class="kw">func</span>(a <span class="dt">int</span>, b <span class="kw">func</span>() <span class="dt">int</span>) <span class="dt">int</span>, acc <span class="dt">int</span>, is []<span class="dt">int</span>) <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb13-19" title="19">        res := acc</a>
<a class="sourceLine" id="cb13-20" title="20">        <span class="kw">for</span> idx := <span class="dv">0</span>; idx &lt; <span class="bu">len</span>(is); idx++ {</a>
<a class="sourceLine" id="cb13-21" title="21">                called := <span class="ot">false</span></a>
<a class="sourceLine" id="cb13-22" title="22">                lambda := <span class="kw">func</span>() <span class="dt">int</span> {</a>
<a class="sourceLine" id="cb13-23" title="23">                        called = <span class="ot">true</span></a>
<a class="sourceLine" id="cb13-24" title="24">                        <span class="kw">return</span> is[idx]</a>
<a class="sourceLine" id="cb13-25" title="25">                }</a>
<a class="sourceLine" id="cb13-26" title="26">                res = fn(res, lambda)</a>
<a class="sourceLine" id="cb13-27" title="27">                <span class="kw">if</span> !called {</a>
<a class="sourceLine" id="cb13-28" title="28">                        <span class="kw">return</span> res</a>
<a class="sourceLine" id="cb13-29" title="29">                }</a>
<a class="sourceLine" id="cb13-30" title="30">        }</a>
<a class="sourceLine" id="cb13-31" title="31">        <span class="kw">return</span> res</a>
<a class="sourceLine" id="cb13-32" title="32">}</a></code></pre></div>
<p>Boom.</p>
<p>Wait just a gosh dang minute. Why's that <code>foldr</code> look so weird? Well, short story is that in Haskell and similarly implemented languages, <code>foldr</code> will thunk the <em>right</em> value and only continue if that value is requested and in that way you can prematurely terminate a right fold. A left fold will not happen as the fold is evaluated <em>from the left</em>. This is a confusing thing if you're not already familiar with it but the basics are that <code>foldl + [1 2 3] -&gt; (1 + (2 + 3))</code> and thus cannot short circuit. Conversely, <code>foldr + [1 2 3] -&gt; (3 + (2 + (1)))</code> and if you notice the 1 in its own parens then you'll notice that the <code>+</code> is only done if the <em>next</em> value is evaluated.</p>
<p>Okay, now boom slam.</p>
<p>That's all for today!</p>


    </div>
    <div id="footer">
      <h6>// social twitter:<a href="https://twitter.com/oynoto">@oynoto</a>, patreon:<a href="https://www.patreon.com/oynot">@oynot</a>, github:<a href="https://github.com/tony-o">tony-o</a></h6>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <script src="/s/hljs-raku.js"></script>
    <script>
      hljs.registerLanguage("raku", hljs_raku);
      (function(){
        languages = {}
        pres      = document.getElementsByTagName("pre");
        for(i = 0; i < hljs.listLanguages().length; i++){
          languages['language-' + hljs.listLanguages()[i]] = 1;
        }
        for(i = 0; i < pres.length; i++){
          pre = pres[i];
          cn  = 'language-plaintext';
          ls  = (pre.getAttribute("class") || 'plaintext').split(' ');
          for(j = 0; j < ls.length; j++){
            if(languages['language-' + ls[j]]){
              cn = 'language-' + ls[j];
              break;
            }
          }
          codes = pre.getElementsByTagName("code")
          for(j = 0; j < codes.length; j++){
            codes[j].setAttribute("class", (codes[j].getAttribute("class") + " hljs " + cn).trim())
          }
        }
        hljs.highlightAll();
      })();
    </script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FKJQZPJ2XK"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-FKJQZPJ2XK');
    </script>

  </body>
</html>
