<!DOCTYPE html>
<html lang="en">
  <head>
    <title>dbks - Dirty Data on Postgres - Read Uncommitted</title>
   	<meta name="description" content="Dirty Data on Postgres - Read Uncommitted" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta content="utf-8" http-equiv="encoding" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/github.min.css" />
    <link rel="stylesheet" href="/s/style.css" />
  </head>
  <body>
    <div id="title">
      <a href="/"><img alt="dbks logo" src="/i/dbks.png" /></a> <a href="/"><h1>deathbykeystroke</h1></a>
    </div>
    <div id="article">
      <h1>Dirty Data on Postgres - Read Uncommitted</h1>
      <h6>// date:  2021-10-15</h6>
      <h6>// filed: <a href="/tags/database.html">database</a>, <a href="/tags/postgres.html">postgres</a></h6>
      <h6>// <a href="https://deathbykeystroke.com/articles/20211015-dirty-data-on-postgres---read-uncommitted.html">perma</a></h6>
      <br/>

      <p>The problem: long running update transactions prevent users from retrieving data from your Postgres database while the lock is active.</p>
<p>Solution: create a "highly available" proof of concept with Postgres that emulates MySQL's Read Uncommitted option.</p>
<h2 id="setup">Setup</h2>
<p>We're going to use docker containers for this so if you're running on hardware you can skip some of the container image steps. While we go through this we'll verify that we can see the problem so that we know our solution actually works.</p>
<h3 id="setup-a-postgres-containers">Setup a Postgres Containers</h3>
<p>For this proof of concept we need a postgres primary and secondary. The primary will provide us with a writeable system of record. It will still respond to read queries but it is the only writeable connection for this exercise.</p>
<p>We're going to use <code>docker-compose</code>, here's the file:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">version:</span><span class="at"> </span><span class="st">&quot;3.9&quot;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">services:</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="fu">db-primary:</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="fu">build:</span></a>
<a class="sourceLine" id="cb1-5" title="5">      <span class="fu">dockerfile:</span><span class="at"> </span><span class="st">&#39;psql.dockerfile&#39;</span></a>
<a class="sourceLine" id="cb1-6" title="6">      <span class="fu">context:</span><span class="at"> </span><span class="st">&#39;.&#39;</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="fu">container_name:</span><span class="at"> psql-primary</span></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="fu">restart:</span><span class="at"> always</span></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="fu">volumes:</span></a>
<a class="sourceLine" id="cb1-10" title="10">      <span class="kw">-</span> <span class="st">&quot;data-primary:/var/lib/postgresql/data&quot;</span></a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="fu">networks:</span></a>
<a class="sourceLine" id="cb1-12" title="12">      <span class="fu">test_net:</span></a>
<a class="sourceLine" id="cb1-13" title="13">        <span class="fu">ipv4_address:</span><span class="at"> </span><span class="st">&#39;172.16.1.200&#39;</span></a>
<a class="sourceLine" id="cb1-14" title="14">        <span class="fu">aliases:</span></a>
<a class="sourceLine" id="cb1-15" title="15">          <span class="kw">-</span> postgres.primary</a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17">  <span class="fu">db-secondary:</span></a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="fu">build:</span></a>
<a class="sourceLine" id="cb1-19" title="19">      <span class="fu">dockerfile:</span><span class="at"> </span><span class="st">&#39;psql.dockerfile&#39;</span></a>
<a class="sourceLine" id="cb1-20" title="20">      <span class="fu">context:</span><span class="at"> </span><span class="st">&#39;.&#39;</span></a>
<a class="sourceLine" id="cb1-21" title="21">      <span class="fu">args:</span></a>
<a class="sourceLine" id="cb1-22" title="22">        <span class="kw">-</span> SECONDARY=true</a>
<a class="sourceLine" id="cb1-23" title="23">    <span class="fu">container_name:</span><span class="at"> psql-secondary</span></a>
<a class="sourceLine" id="cb1-24" title="24">    <span class="fu">restart:</span><span class="at"> always</span></a>
<a class="sourceLine" id="cb1-25" title="25">    <span class="fu">volumes:</span></a>
<a class="sourceLine" id="cb1-26" title="26">      <span class="kw">-</span> <span class="st">&quot;data-secondary:/var/lib/postgresql/data&quot;</span></a>
<a class="sourceLine" id="cb1-27" title="27">    <span class="fu">networks:</span></a>
<a class="sourceLine" id="cb1-28" title="28">      <span class="fu">test_net:</span></a>
<a class="sourceLine" id="cb1-29" title="29">        <span class="fu">ipv4_address:</span><span class="at"> </span><span class="st">&#39;172.16.1.201&#39;</span></a>
<a class="sourceLine" id="cb1-30" title="30">        <span class="fu">aliases:</span></a>
<a class="sourceLine" id="cb1-31" title="31">          <span class="kw">-</span> postgres.secondary</a>
<a class="sourceLine" id="cb1-32" title="32">    <span class="fu">environment:</span></a>
<a class="sourceLine" id="cb1-33" title="33">      <span class="fu">PRIMARY_CONNINFO:</span><span class="at"> </span><span class="st">&quot;psql://172.16.1.200:5432/&quot;</span></a>
<a class="sourceLine" id="cb1-34" title="34"></a>
<a class="sourceLine" id="cb1-35" title="35"><span class="fu">networks:</span></a>
<a class="sourceLine" id="cb1-36" title="36">  <span class="fu">test_net:</span></a>
<a class="sourceLine" id="cb1-37" title="37">    <span class="fu">ipam:</span></a>
<a class="sourceLine" id="cb1-38" title="38">      <span class="fu">driver:</span><span class="at"> default</span></a>
<a class="sourceLine" id="cb1-39" title="39">      <span class="fu">config:</span></a>
<a class="sourceLine" id="cb1-40" title="40">      <span class="kw">-</span> <span class="fu">subnet:</span><span class="at"> </span><span class="st">&quot;172.16.1.0/24&quot;</span></a>
<a class="sourceLine" id="cb1-41" title="41"></a>
<a class="sourceLine" id="cb1-42" title="42"><span class="fu">volumes:</span></a>
<a class="sourceLine" id="cb1-43" title="43">  <span class="fu">data-secondary:</span></a>
<a class="sourceLine" id="cb1-44" title="44">  <span class="fu">data-primary:</span></a></code></pre></div>
<p>For more information about docker-compose, check that out <a href="https://docs.docker.com/compose/">here</a>.</p>
<p>The important thing to note here is the <code>environment</code> and <code>build.args</code> keys in the file. Both of these are controlling the image and container in such a way that it runs as either the primary (write/read) or as a secondary (read-only).</p>
<p>The <code>psql.dockerfile</code> boils down to this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" title="1">FROM postgres:14</a>
<a class="sourceLine" id="cb2-2" title="2">COPY postgres.defaults.conf /tmp/</a>
<a class="sourceLine" id="cb2-3" title="3">ARG SECONDARY</a>
<a class="sourceLine" id="cb2-4" title="4">ENV SECONDARY $SECONDARY</a>
<a class="sourceLine" id="cb2-5" title="5">RUN su postgres -c initdb \</a>
<a class="sourceLine" id="cb2-6" title="6"> <span class="dt">&amp;&amp;</span> su postgres -c <span class="st">&#39;pg_ctl -D /var/lib/postgresql/data start&#39;</span> \</a>
<a class="sourceLine" id="cb2-7" title="7"> <span class="dt">&amp;&amp;</span> su postgres -c <span class="st">&#39;psql -c &quot;CREATE USER replicator WITH REPLICATION ENCRYPTED PASSWORD &#39;&quot;&#39;test&#39;&quot;&#39;;&quot;&#39;</span> \</a>
<a class="sourceLine" id="cb2-8" title="8"> <span class="dt">&amp;&amp;</span> su postgres -c <span class="st">&#39;pg_ctl -D /var/lib/postgresql/data stop&#39;</span> \</a>
<a class="sourceLine" id="cb2-9" title="9"> <span class="dt">&amp;&amp;</span> cp /tmp/postgres.defaults.conf /var/lib/postgresql/data/postgres.conf \</a>
<a class="sourceLine" id="cb2-10" title="10"> <span class="dt">&amp;&amp;</span> if test <span class="st">&quot;${SECONDARY}&quot;</span> = <span class="st">&#39;true&#39;</span>; then \</a>
<a class="sourceLine" id="cb2-11" title="11">      echo <span class="st">&#39;hot_standby = on&#39;</span> &gt;&gt; <span class="st">&#39;/var/lib/postgresql/data/postgresql.conf&#39;</span>; \</a>
<a class="sourceLine" id="cb2-12" title="12">      echo <span class="st">&#39;primary_conninfo = &#39;&quot;&#39;user=replicator password=test channel_binding=prefer host=172.16.1.200 port=5432 sslmode=prefer sslcompression=0 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres target_session_attrs=any&#39;&quot;</span> &gt;&gt; <span class="st">&#39;/var/lib/postgresql/data/postgresql.conf&#39;</span>; \</a>
<a class="sourceLine" id="cb2-13" title="13">      touch /var/lib/postgresql/data/standby.signal; \</a>
<a class="sourceLine" id="cb2-14" title="14">    else \</a>
<a class="sourceLine" id="cb2-15" title="15">      echo <span class="st">&quot;host replication replicator 172.16.1.201/32 trust&quot;</span> &gt;&gt; <span class="st">&#39;/var/lib/postgresql/data/pg_hba.conf&#39;</span>; \</a>
<a class="sourceLine" id="cb2-16" title="16">      echo <span class="st">&quot;host all postgres 172.16.1.100/24 trust&quot;</span> &gt;&gt; <span class="st">&#39;/var/lib/postgresql/data/pg_hba.conf&#39;</span>; \</a>
<a class="sourceLine" id="cb2-17" title="17">    fi</a>
<a class="sourceLine" id="cb2-18" title="18"></a>
<a class="sourceLine" id="cb2-19" title="19">CMD <span class="kw">[</span><span class="st">&quot;bash&quot;</span><span class="kw">,</span> <span class="st">&quot;-c&quot;</span><span class="kw">,</span> <span class="st">&quot;if [[ $SECONDARY = &#39;true&#39; ]]; then rm -Rf /var/lib/postgresql/data/*; su postgres -c &#39;pg_basebackup -h 172.16.1.200 -U replicator -p 5432 -D /var/lib/postgresql/data -Fp -Xs -P -R&#39;; fi; su postgres -c &#39;postgres -D /var/lib/postgresql/data&#39;&quot;</span><span class="kw">]</span></a></code></pre></div>
<p>If you're using this tutorial for production then do a little more research and use individual config files rather than mangling them with bash as we're doing here. This isn't a secure way of allowing replication.</p>
<p>Now, if you run <code>docker-compose up</code> you should see the primary start and the secondary eventually start. Don't be worried about the secondary failing a few times during startup, this may happen because the primary may take a few minutes to start accepting connections.</p>
<h2 id="now-build-the-dog-in-our-corn-dog">Now Build the Dog in Our Corn Dog</h2>
<p>This is how we're going to allow users to get a dirty read from the secondary while the primary is updating. Let's add pgpool-II. You can read about it more in depth <a href="https://www.pgpool.net/mediawiki/index.php/Main_Page">here</a>. We're going to add the following service to our compose file:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" title="1">  <span class="fu">pgpool:</span></a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="fu">build:</span></a>
<a class="sourceLine" id="cb3-3" title="3">      <span class="fu">dockerfile:</span><span class="at"> </span><span class="st">&#39;pgpool.dockerfile&#39;</span></a>
<a class="sourceLine" id="cb3-4" title="4">      <span class="fu">context:</span><span class="at"> </span><span class="st">&#39;.&#39;</span></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="fu">container_name:</span><span class="at"> </span><span class="st">&#39;pgpool&#39;</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="fu">restart:</span><span class="at"> always</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="fu">networks:</span></a>
<a class="sourceLine" id="cb3-8" title="8">      <span class="fu">test_net:</span></a>
<a class="sourceLine" id="cb3-9" title="9">        <span class="fu">ipv4_address:</span><span class="at"> </span><span class="st">&#39;172.16.1.100&#39;</span></a>
<a class="sourceLine" id="cb3-10" title="10">        <span class="fu">aliases:</span></a>
<a class="sourceLine" id="cb3-11" title="11">          <span class="kw">-</span> pgpool</a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="fu">ports:</span></a>
<a class="sourceLine" id="cb3-13" title="13">      <span class="kw">-</span> <span class="st">&quot;5432:5432&quot;</span></a></code></pre></div>
<p>With the <code>pgpool.dockerfile</code> containing:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" title="1">FROM alpine:3.13.6</a>
<a class="sourceLine" id="cb4-2" title="2">COPY pgpool.conf /etc/pgpool/pgpool.conf</a>
<a class="sourceLine" id="cb4-3" title="3">RUN apk update \</a>
<a class="sourceLine" id="cb4-4" title="4"> <span class="dt">&amp;&amp;</span> apk add pgpool \</a>
<a class="sourceLine" id="cb4-5" title="5"> <span class="dt">&amp;&amp;</span> mkdir /var/run/pgpool</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7">CMD <span class="kw">[</span><span class="st">&quot;pgpool&quot;</span><span class="kw">,</span> <span class="st">&quot;-n&quot;</span><span class="kw">]</span></a></code></pre></div>
<p>In a <code>pgpool.conf</code> make sure you have these important bits along with other config info (a full sample can be found <a href="/f/pgpool.sample.conf">here</a>).</p>
<pre><code> # - Backend Connection Settings -
 backend_hostname0 = &#39;172.16.1.200&#39; #primary
 backend_port0 = 5432
 backend_weight0 = 40
 backend_data_directory0 = &#39;/data&#39;
 backend_flag0 = &#39;ALLOW_TO_FAILOVER&#39;

 backend_hostname1 = &#39;172.16.1.201&#39; #secondary
 backend_port1 = 5432
 backend_weight1 = 60
 backend_data_directory1 = &#39;/data1&#39;
 backend_flag1 = &#39;ALLOW_TO_FAILOVER&#39;</code></pre>
<p>Now we're all set.</p>
<p>You can now query from postgres while something locks the table, you can test this by running <code>docker-compose up</code>, connecting your sql client and doing the following:</p>
<p>Client 1:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">CREATE</span> <span class="kw">TABLE</span> test_lock (t text);</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">INSERT</span> <span class="kw">INTO</span> test_lock (t) <span class="kw">VALUES</span> (<span class="st">&#39;this is only a test&#39;</span>);</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="cf">BEGIN</span> <span class="kw">WORK</span>;</a>
<a class="sourceLine" id="cb6-4" title="4"><span class="kw">LOCK</span> test_lock <span class="kw">IN</span> <span class="kw">EXCLUSIVE</span> <span class="kw">MODE</span>;</a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">-- leave this transaction open while you run in your second window</span></a></code></pre></div>
<p>Client 2:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> test_lock;</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="co">--    test</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="co">-- ----------</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="co">--  test str</span></a>
<a class="sourceLine" id="cb7-5" title="5">(<span class="dv">1</span> <span class="kw">row</span>)</a></code></pre></div>
<p>Now you can issue the <code>END WORK;</code> in Client 1 to remove the lock</p>
<p>Now, let's verify that our pgpool is <em>really</em> working and that it's actually allowing us to run queries.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="ex">docker-compose</span> up pgpool pg-primary</a></code></pre></div>
<p>Now when you run your test above, Client 2 will block until you <code>END WORK;</code>.</p>
<p>If you'd like to check this out as a repo all of the files for building can be found on <a href="https://github.com/tony-o/tony-o.github.io/tree/master/scratch/pgpool">github</a></p>
<h2 id="what-exactly-did-we-do">What Exactly Did We Do?</h2>
<p>Well, we made dirty data available to consumers who don't require <em>exactly</em> correct data at read time. This can be something as simple as we're just showing a user some data that we know to be true at the time of request. Here's a couple of charts so we can see exactly what's going on.</p>
<figure>
<img src="/f/standalone-pg.svg" alt="Standalone Postgres" /><figcaption>Standalone Postgres</figcaption>
</figure>
<p>From this chart you can see the time that the action happens on the left and how much time has elapsed through the process. You'll notice that Client 2 becomes blocked for the entirety of the lock created by Client 1. This creates a pretty poor user experience if they have to wait 45 seconds just to view their own profile data while you run a migration.</p>
<p>Conversely, this is how PGPool-II would handle this situation.</p>
<figure>
<img src="/f/pgpool-ii.svg" alt="PGPool-II" /><figcaption>PGPool-II</figcaption>
</figure>
<p>From this you can see that PGPool is actually routing Client 2's read request to the replicated secondary and avoiding the lock on the primary postgres server. In doing so you're potentially giving the client data that is going to be different a second from now but you're also avoiding making your user wait until a long running table lock completes.</p>
<p>From here you can move ahead to testing, proposing, and building out better configurations for all of these but this should get you started towards making your dreams come true or at least making them readable while you update them.</p>


    </div>
    <div id="footer">
      <h6>// social twitter:<a href="https://twitter.com/oynoto">@oynoto</a>, patreon:<a href="https://www.patreon.com/oynot">@oynot</a>, github:<a href="https://github.com/tony-o">tony-o</a></h6>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <script src="/s/hljs-raku.js"></script>
    <script>
      hljs.registerLanguage("raku", hljs_raku);
      (function(){
        languages = {}
        pres      = document.getElementsByTagName("pre");
        for(i = 0; i < hljs.listLanguages().length; i++){
          languages['language-' + hljs.listLanguages()[i]] = 1;
        }
        for(i = 0; i < pres.length; i++){
          pre = pres[i];
          cn  = 'language-plaintext';
          ls  = (pre.getAttribute("class") || 'plaintext').split(' ');
          for(j = 0; j < ls.length; j++){
            if(languages['language-' + ls[j]]){
              cn = 'language-' + ls[j];
              break;
            }
          }
          codes = pre.getElementsByTagName("code")
          for(j = 0; j < codes.length; j++){
            codes[j].setAttribute("class", (codes[j].getAttribute("class") + " hljs " + cn).trim())
          }
        }
        hljs.highlightAll();
      })();
    </script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FKJQZPJ2XK"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-FKJQZPJ2XK');
    </script>

  </body>
</html>
