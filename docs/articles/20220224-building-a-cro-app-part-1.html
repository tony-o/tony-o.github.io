<!DOCTYPE html>
<html lang="en">
  <head>
    <title>dbks - Building a Cro App - Part 1</title>
   	<meta name="description" content="Building a Cro App - Part 1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta content="utf-8" http-equiv="encoding" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/base16/danqing.min.css" />
    <link rel="stylesheet" href="/s/style.css" />
  </head>
  <body>
    <div id="title">
      <a href="/"><img alt="dbks logo" src="/i/dbks.png" /></a> <a href="/"><h1>deathbykeystroke</h1></a>
    </div>
    <div id="article">
      <h1>Building a Cro App - Part 1</h1>
      <h6>// date:  2022-02-24</h6>
      <h6>// filed: <a href="/tags/rakudo.html">rakudo</a>, <a href="/tags/programming.html">programming</a></h6>
      <h6>// <a href="https://deathbykeystroke.com/articles/20220224-building-a-cro-app-part-1.html">perma</a></h6>
      <br/>

      <p>This whole article will encompass building a Cro application (with DB and templating), configuring your apache web server, and ensuring your app is running with systemd.</p>
<h2 id="part-1---building-the-cro-app">Part 1 - Building the Cro app</h2>
<p>We're going to build a little 90s style forum, like Bytamin-C. This allows users to log in and participate in some chats and have a profile, or surf around and view some of the chats others are having.</p>
<p>Let's set up our directory structure first:</p>
<pre><code>.
├── bin
│   └── app
├── lib
├── META6.json
├── resources
└── templates</code></pre>
<p>In <code>bin/app</code> we'll have nothing for the time being, this will eventually be the script we use to start the webserver. In <code>META6.json</code> lets add the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="fu">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="dt">&quot;name&quot;</span><span class="fu">:</span>        <span class="st">&quot;Demo&quot;</span><span class="fu">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="dt">&quot;auth&quot;</span><span class="fu">:</span>        <span class="st">&quot;zef:tony-o&quot;</span><span class="fu">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="dt">&quot;version&quot;</span><span class="fu">:</span>     <span class="st">&quot;0.0.1&quot;</span><span class="fu">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="dt">&quot;api&quot;</span><span class="fu">:</span>         <span class="st">&quot;0&quot;</span><span class="fu">,</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;A demo cro app&quot;</span><span class="fu">,</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  <span class="dt">&quot;depends&quot;</span><span class="fu">:</span>     <span class="ot">[</span><span class="st">&quot;cro&quot;</span><span class="ot">,</span> <span class="st">&quot;Cro::WebApp::Template&quot;</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  <span class="dt">&quot;provides&quot;</span><span class="fu">:</span>    <span class="fu">{}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="fu">}</span></span></code></pre></div>
<p>After doing this, you can run <code>zef install --/test --depsonly .</code> and you should end up with our app's dependencies so we can start filling out the rest.</p>
<h3 id="the-binapp">The <code>bin/app</code></h3>
<p>Typically stuff inside of the bin directory doesn't gain the benefit of precompilation. To gain some start up speed and benefits, the <code>bin/app</code> file will just be stubbed to start our app. So let's create the bit we want precompiled in <code>lib/Demo/App.rakumod</code> add the following:</p>
<pre class="raku"><code>unit module Demo::App;

use Cro::HTTP::Router;
use Cro::HTTP::Server;
use Config;

my $application = route {
  get -&gt; &#39;greet&#39;, $name {
    content &#39;text/plain&#39;, &quot;Hello, $name!&quot;;
  }
}

my $host = config&lt;listen-ip&gt;   // &#39;0.0.0.0&#39;;
my $port = config&lt;listen-port&gt; // 10000;

my Cro::Service $service = Cro::HTTP::Server.new(:$host, :$port, :$application);

$service.start;

say &quot;Listening: $host:$port&quot;;

react whenever signal(SIGINT) {
  $service.stop;
  exit;
}</code></pre>
<p>You'll see we're including something called <code>Config</code>, we haven't created this yet so let's add this to <code>lib/Config.rakumod</code>:</p>
<pre class="raku"><code>unit module Config;

sub config is export {
  {
    listen-ip   =&gt; &#39;127.0.0.1&#39;,
    listen-port =&gt; 8666,
  };
}</code></pre>
<p>Now, as we add things that need configuration we can add those to this file. There are plenty of ways to include config and if you're storing passwords and secrets then this module should retrieve those in a secure way. We still can't run this app to test it until we modify the <code>provides</code> in our <code>META6.json</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="fu">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="er">...</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="dt">&quot;provides&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="dt">&quot;Demo::App&quot;</span><span class="fu">:</span> <span class="st">&quot;lib/Demo/App.rakumod&quot;</span><span class="fu">,</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="dt">&quot;Config&quot;</span><span class="fu">:</span>    <span class="st">&quot;lib/Config.rakumod&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>  <span class="fu">}</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="fu">}</span></span></code></pre></div>
<p>Now, when you run: <code>raku -I. -e 'use Demo::App'</code> you'll get the message of where your server is listening and if you hit that ip/port + <code>/greet/world</code> with your browser (<code>http://127.0.0.1:8666</code> if you didn't modify the config) then you should get a nice message of <code>Hello, world!</code>. This means our server is working. Let's stub it out now, in <code>bin/app</code>:</p>
<pre class="raku"><code>#!/usr/bin/env raku
use Demo::App;</code></pre>
<p>Now your server can run with <code>raku -I. bin/app</code> and you can hit the same endpoint you did above for great success.</p>
<h3 id="building-templates-and-static-files">Building Templates and Static Files</h3>
<h4 id="static-files">Static Files</h4>
<p>Serving static files is fairly simple in cro, add the following routes to <code>lib/Demo/App.rakumod</code>:</p>
<pre class="raku"><code>get -&gt; &#39;style&#39;, *@path {
  static &#39;static/style&#39;, @path;
}

get -&gt; &#39;script&#39;, *@path {
  static &#39;static/script&#39;, @path;
}</code></pre>
<p>Cro protects us against a query like <code>/script/../db.sqlite</code> so we don't need to worry about path resolution ending up outside of our static file directories. You now need to create the directories <code>static/style</code> and <code>static/script</code> and you should have the directory structure of:</p>
<pre><code>.
├── bin
│   └── app
├── lib
│   ├── Config.rakumod
│   └── Demo
│       └── App.rakumod
├── META6.json
├── resources
├── static
│   ├── script
│   └── style
└── templates</code></pre>
<p>That's it for static files.</p>
<h4 id="templates">Templates</h4>
<p>Cro has the concept of partials so we're going to modify our <code>greet/$name</code> route to work off of a template.</p>
<p>First, change our <code>use</code> block in <code>lib/Demo/App.rakumod</code> to include <code>Cro::WebApp::Template</code>:</p>
<pre class="raku"><code>unit module Demo::App;

use Cro::HTTP::Router;
use Cro::HTTP::Server;
use Cro::WebApp::Template;

use Config;</code></pre>
<p>And modify our application's route block to be:</p>
<pre class="raku"><code>my $application = route {
  template-location &#39;templates/&#39;;

  get -&gt; &#39;greet&#39;, $name {
    template &#39;main.crotmp&#39;, {:$name};
  }
}</code></pre>
<p>With these changes we're telling cro to look in the <code>templates/</code> directory for whatever <code>.crotmp</code> first and we're telling our greeter route to use a template giving it access to the <code>$name</code> variable. Now we need to create the template <code>templates/main.crotmp</code>:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    Greetings, &lt;.name&gt;!
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Now firing up our application and visiting our server at <code>/greet/world</code> we'll get the same message but this time complete with html! Now let's build out our authorization and functionality.</p>
<h3 id="building-our-applications-functionality">Building Our Application's Functionality</h3>
<p>If we want to let users post and sign up, we're going to want a database. Let's define our table schemas (using SQLite for this demo), in <code>schema.sql</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> users (</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="kw">id</span>         UUID <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  name       TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  foreign_id TEXT</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>);</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> posts (</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  <span class="kw">id</span>      UUID <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>  author  UUID <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>  title   TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>  <span class="kw">body</span>    TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>  <span class="kw">parent</span>  UUID,</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>  <span class="kw">FOREIGN</span> <span class="kw">KEY</span>(author) <span class="kw">REFERENCES</span> users(<span class="kw">id</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>);</span></code></pre></div>
<p>Now run <code>sqlite3 resources/db.sqlite &lt; schema.sql</code>, you should now have a <code>db.sqlite</code> database with our posts and users ready to use. Let's make sure we keep our <code>META6.json</code> up to date, add a <code>resources</code> key:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="fu">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>  <span class="er">...</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="dt">&quot;provides&quot;</span><span class="fu">:</span> <span class="fu">{</span><span class="er">...</span><span class="fu">},</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  <span class="dt">&quot;resources&quot;</span><span class="fu">:</span> <span class="ot">[</span> <span class="st">&quot;db.sqlite&quot;</span> <span class="ot">]</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="fu">}</span></span></code></pre></div>
<p>We're going to morph our greeter route to just be our app's main route and allow people to log in. In <code>lib/Demo/App.rakumod</code> make the modifications to our <code>$application</code>:</p>
<pre class="raku"><code>my $application = route {
  template-location &#39;templates/&#39;;

  get -&gt; {
    template &#39;main.crotmp&#39;;
  }
}</code></pre>
<p>Now we're at a break point. For this article we're going to use github's oauth so you'll need to take a break from this article and create a github oauth app (at the time of writing this, the path in github is <code>Settings/Developer Settings</code>) with the following info:</p>
<figure>
<img src="/i/ghscreen1.png" alt="" /><figcaption>Github Screenshot</figcaption>
</figure>
<p>Now we need the secret you generated and the client id in <code>lib/Config.rakumod</code>:</p>
<pre class="raku"><code>sub config is export {
  { 
    listen-ip   =&gt; &#39;127.0.0.1&#39;,
    listen-port =&gt; 8666,
    gh-secret   =&gt; &#39;d4......................6bb9d3&#39;,
    gh-client   =&gt; &#39;85c...fc50decdf74c8&#39;,
  };
}</code></pre>
<p>Okay! Let's build out an OAuth flow. Essentially what happens in OAuth is:</p>
<ol>
<li>Your app directs the user to the OAuth provider with a list of grants (what resources we want access to)</li>
<li>The user succeeds or fails at the login (if fails then this process stops)</li>
<li>The provider gives our server an authorization grant</li>
<li>Our server then requests an access token from the provider</li>
<li>We can use that access token to request information from the OAuth provider within the scope of our grants</li>
</ol>
<p>We're going to modify our route to our application:</p>
<pre class="raku"><code>class SessionVar does Cro::HTTP::Auth {
  has $.user         is rw;
  has $.user-id      is rw;
  has $.login-state  is rw;
}

my $client      = HTTP::Tinyish.new;
my $db          = DB::SQLite.new(filename =&gt; %?RESOURCES&lt;db.sqlite&gt;.absolute);
my $application = route {
  template-location &#39;templates/&#39;;

  before Cro::HTTP::Session::InMemory[SessionVar].new(
    expiration  =&gt; Duration.new(60*60),
    cookie-name =&gt; &#39;demo-app&#39;,
  );

  get -&gt; SessionVar \session {
    template &#39;main.crotmp&#39;, {
      user      =&gt; session.user,
      logged-in =&gt; (session.user-id ?? True !! False),
    };
  }

  get -&gt; SessionVar \session, &#39;oauth&#39; {
    session.login-state = (&#39;a&#39; .. &#39;z&#39;).pick(24).sort.join(&#39;&#39;);
    redirect &#39;https://github.com/login/oauth/authorize&#39;
           ~ &quot;?client_id={encode-percents: config&lt;gh-client&gt;}&quot;
           ~ &quot;&amp;redirect_uri={encode-percents: &quot;http://localhost:8666/oauth2&quot;}&quot;
           ~ &quot;&amp;state={encode-percents: session.login-state}&quot;;
  }

  get -&gt; SessionVar \session, &#39;oauth2&#39;, :$state! is query, Str :$code! is query, :$error? is query {
    redirect &#39;/&#39; if $error.defined;
    my $resp = $client.post(
      headers =&gt; {Accept =&gt; &#39;application/json&#39;},
      &#39;https://github.com/login/oauth/access_token&#39;
      ~ &quot;?client_id={encode-percents: config&lt;gh-client&gt; }&quot;
      ~ &quot;&amp;client_secret={encode-percents: config&lt;gh-secret&gt; }&quot;
      ~ &quot;&amp;code={encode-percents: $code }&quot;,
    );
    redirect &#39;/&#39; unless 200 &lt;= $resp&lt;status&gt; &lt;= 201;
    redirect &#39;/?error=state-mismatch&#39; unless $state eq session.login-state;

    # Now get the user info so we can create a user
    my $json = from-json($resp&lt;content&gt;);
    $resp = $client.get(
      headers =&gt; {Authorization =&gt; &quot;token {$json&lt;access_token&gt;}&quot;},
      &quot;https://api.github.com/user&quot;,
    );
    $json = from-json($resp&lt;content&gt;);

    # determine if user exists
    my $user = $db.query(&#39;select * from users where foreign_id = ?&#39;,  $json&lt;id&gt;).hash;
    if ($user&lt;foreign_id&gt;//&#39;&#39;) ne $json&lt;id&gt; {
      # create them
      my $id = UUID.new.Str;
      $db.query(&#39;insert into users (id, name, foreign_id) values (?, ?, ?);&#39;, $id, $json&lt;name&gt;, $json&lt;id&gt;);
      $user = $db.query(&#39;select * from users where id = ?&#39;,  $id).hash;
    }

    # if the db failed for whatever reason, don&#39;t set the user session
    if ($user&lt;foreign_id&gt;//&#39;&#39;) eq $json&lt;id&gt; {
      session.user = $user;
      session.user-id = $user&lt;id&gt;;
    }
    redirect &#39;/&#39;;
  }
}</code></pre>
<p>Oof, this is a huge change, let's break it down. First big modification is the introduction of a session to our app. We're going to keep our user data in the session so we don't need to load it every request so we can tell cro to hold that in a session object resembling the <code>SessionVar</code> class we've designed.</p>
<pre class="raku"><code># This will hold our session data
class SessionVar does Cro::HTTP::Auth {
  has $.user    is rw;
  has $.user-id is rw;
}
...

  # This tells Cro we want an InMemory session resembling SessionVar
  before Cro::HTTP::Session::InMemory[SessionVar].new(
    expiration  =&gt; Duration.new(60*60),
    cookie-name =&gt; &#39;demo-app&#39;,
  );</code></pre>
<p>Now we need to set up our redirect. This could also be done in a link rather than as an endpoint for our API but this is also fine.</p>
<pre class="raku"><code>  get -&gt; SessionVar \session, &#39;oauth&#39; {
    session.login-state = (&#39;a&#39; .. &#39;z&#39;).pick(24).sort.join(&#39;&#39;);
    redirect &#39;https://github.com/login/oauth/authorize&#39;
           ~ &quot;?client_id={encode-percents: config&lt;gh-client&gt;}&quot;
           ~ &quot;&amp;redirect_uri={encode-percents: &quot;http://localhost:8666/oauth2&quot;}&quot;  # take note of this url, this is where we&#39;ll handle the login
           ~ &quot;&amp;state={encode-percents: session.login-state}&quot;;
  }</code></pre>
<p>Now, if you were to fire up your server and have your github OAuth settings correct, you could hit <code>/oauth</code> and you'd be presented with the nice github authorization screen.</p>
<p>Now, once a user accepts or rejects the login request, we need to handle it:</p>
<pre class="raku"><code>  get -&gt; SessionVar \session, &#39;oauth2&#39;, :$state! is query, Str :$code! is query, :$error? is query {
    # If the user declined oauth, redirect home
    redirect &#39;/&#39; if $error.defined;

    # Here we&#39;re cashing in the code we got back from our redirect so that we can
    # later request information about the user.
    my $resp = $client.post(
      headers =&gt; {Accept =&gt; &#39;application/json&#39;},
      &#39;https://github.com/login/oauth/access_token&#39;
      ~ &quot;?client_id={encode-percents: config&lt;gh-client&gt; }&quot;
      ~ &quot;&amp;client_secret={encode-percents: config&lt;gh-secret&gt; }&quot;
      ~ &quot;&amp;code={encode-percents: $code }&quot;,
    );

    # Go home if this code exchange failed.
    redirect &#39;/&#39; unless 200 &lt;= $resp&lt;status&gt; &lt;= 201;
    # Go home if what we go back from the server is not what we expected
    redirect &#39;/?error=state-mismatch&#39; unless $state eq session.login-state;

    # Now get the user info so we can create a user
    my $json = from-json($resp&lt;content&gt;);
    $resp = $client.get(
      headers =&gt; {Authorization =&gt; &quot;token {$json&lt;access_token&gt;}&quot;},
      &quot;https://api.github.com/user&quot;,
    );
    $json = from-json($resp&lt;content&gt;);

    # determine if user exists
    my $user = $db.query(&#39;select * from users where foreign_id = ?&#39;,  $json&lt;id&gt;).hash;
    if ($user&lt;foreign_id&gt;//&#39;&#39;) ne $json&lt;id&gt; {
      # create them
      my $id = UUID.new.Str;
      $db.query(&#39;insert into users (id, name, foreign_id) values (?, ?, ?);&#39;, $id, $json&lt;name&gt;, $json&lt;id&gt;);
      $user = $db.query(&#39;select * from users where id = ?&#39;,  $id).hash;
    }

    # if the db failed for whatever reason, don&#39;t set the user session
    if ($user&lt;foreign_id&gt;//&#39;&#39;) eq $json&lt;id&gt; {
      session.user = $user;
      session.user-id = $user&lt;id&gt;;
    }
    redirect &#39;/&#39;;
  }</code></pre>
<p>Along with all this functionality, we also need to update our dependencies and project meta. The new <code>use</code> block:</p>
<pre class="raku"><code>use Cro::HTTP::Router;
use Cro::HTTP::Server;
use Cro::HTTP::Session::InMemory;
use Cro::WebApp::Template;
use Cro::Uri :encode-percents;
use HTTP::Tinyish;
use JSON::Fast;
use DB::SQLite;
use UUID;</code></pre>
<p>and our new <code>META6.json</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="fu">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>  <span class="dt">&quot;name&quot;</span><span class="fu">:</span>        <span class="st">&quot;Demo&quot;</span><span class="fu">,</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>  <span class="dt">&quot;auth&quot;</span><span class="fu">:</span>        <span class="st">&quot;zef:tony-o&quot;</span><span class="fu">,</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>  <span class="dt">&quot;version&quot;</span><span class="fu">:</span>     <span class="st">&quot;0.0.1&quot;</span><span class="fu">,</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>  <span class="dt">&quot;api&quot;</span><span class="fu">:</span>         <span class="st">&quot;0&quot;</span><span class="fu">,</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  <span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;A demo cro app&quot;</span><span class="fu">,</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>  <span class="dt">&quot;depends&quot;</span><span class="fu">:</span>     <span class="ot">[</span><span class="st">&quot;cro&quot;</span><span class="ot">,</span> <span class="st">&quot;Cro::WebApp::Template&quot;</span><span class="ot">,</span> <span class="st">&quot;HTTP::Tinyish&quot;</span><span class="ot">,</span> <span class="st">&quot;DB::SQLite&quot;</span><span class="ot">,</span> <span class="st">&quot;UUID&quot;</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>  <span class="dt">&quot;provides&quot;</span><span class="fu">:</span>    <span class="fu">{</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>    <span class="dt">&quot;Demo::App&quot;</span><span class="fu">:</span> <span class="st">&quot;lib/Demo/App.rakumod&quot;</span><span class="fu">,</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>    <span class="dt">&quot;Config&quot;</span><span class="fu">:</span>    <span class="st">&quot;lib/Config.rakumod&quot;</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a>  <span class="fu">},</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>  <span class="dt">&quot;resources&quot;</span><span class="fu">:</span>  <span class="ot">[</span> <span class="st">&quot;db.sqlite&quot;</span> <span class="ot">]</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a><span class="fu">}</span></span></code></pre></div>
<p>Now, last thing before we can test. Our <code>/</code> route has changed to use our session rather than just lounging around. Let's update our template to take advantage of our new powers.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="kw">&lt;html&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  <span class="kw">&lt;head</span> <span class="kw">/&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  <span class="kw">&lt;body&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>    <span class="er">&lt;</span>!.logged-in&gt; <span class="co">&lt;!-- if we&#39;re not logged in !--&gt;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>      <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;/oauth&quot;</span><span class="kw">&gt;</span>Login<span class="kw">&lt;/a&gt;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>    <span class="er">&lt;</span>/!&gt;</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>    <span class="kw">&lt;?</span>.logged-in&gt; &lt;!-- if we&#39;re logged in !--&gt;</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>      Welcome, &lt;.user.name&gt;</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>    &lt;/<span class="kw">?&gt;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a>  <span class="kw">&lt;/body&gt;</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a><span class="kw">&lt;/html&gt;</span></span></code></pre></div>
<p>Fire that bad boy up with <code>raku -I. bin/app</code> and now when you first visit your site you'll get a <code>login</code> link and if you decline then you'll just be shown the login link, if you choose to accept fate then you should see a nice little display of your github name for the subsequent requests.</p>
<p>At this point, if you were doing this in an effort to build something robust, you'd likely start look at real SQL servers and the available connection pools for them so you don't have one DB reference. You'd also probably start looking at session backends that are more persistent.</p>
<h4 id="members-only-public-pages-and-a-mix-of-both">Members Only, Public Pages, and a Mix of Both</h4>
<p>Now all that's left is to make a couple of pages.</p>
<ul>
<li>Create a new topic (only available if logged in)</li>
<li>View a topic</li>
<li><ul>
<li>List hierarchy of replies</li>
</ul></li>
<li><ul>
<li>Show respond form if logged in</li>
</ul></li>
</ul>
<p>First let's show a link to make a post only if the user is logged in. In <code>templates/main.crotmp</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="kw">&lt;html&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  <span class="kw">&lt;head</span> <span class="kw">/&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>  <span class="kw">&lt;body&gt;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    <span class="er">&lt;</span>!.logged-in&gt;</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>      <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;/oauth&quot;</span><span class="kw">&gt;</span>Login<span class="kw">&lt;/a&gt;</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>    <span class="er">&lt;</span>/!&gt;</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>    <span class="kw">&lt;?</span>.logged-in&gt;</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>      Welcome, &lt;.user.name&gt; | &lt;a href=&quot;/post&quot;&gt;New Post&lt;/a&gt;</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>    &lt;/<span class="kw">?&gt;</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>  <span class="kw">&lt;/body&gt;</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a><span class="kw">&lt;/html&gt;</span></span></code></pre></div>
<p>The new route (in <code>lib/Demo/App.rakumod</code>):</p>
<pre class="raku"><code>  # Anything requiring this subset will not match unless their session `user-id` is defined
  subset LoggedIn of SessionVar where *.user-id ?? True !! False;

  # The actual `create post` route
  get -&gt; LoggedIn \session, &#39;post&#39; {
    # This is necessary because we provide no other handlers if the user isn&#39;t logged in
    redirect &#39;/oauth&#39; unless session.user-id;

    template &#39;post.crotmp&#39;, { title =&gt; &#39;&#39;, body =&gt; &#39;&#39;, errors =&gt; [] };
  }

  # Handle the POST request to make the post
  post -&gt; LoggedIn \session, &#39;post&#39; {
    # This is necessary because we provide no other handlers if the user isn&#39;t logged in
    redirect &#39;/oauth&#39; unless session.user-id;

    request-body -&gt; (:$title, :$body) {
      # Handle all of the errors so the user isn&#39;t clicking back and forth to fix every single
      # issue.
      my @errors;
      @errors.push(&#39;Title cannot be fewer than five characters&#39;) if $title.chars &lt;= 5;
      @errors.push(&#39;Post cannot be fewer than fifty characters&#39;) if $body.chars &lt;= 50;

      if @errors {
        template &#39;post.crotmp&#39;, {
          :$title,
          :$body,
          :@errors,
        };
        last;
      }

      
      my $id = UUID.new.Str;
      my $ok = $db.query(&#39;insert into posts (id, title, body, author) values (?, ?, ?, ?);&#39;, $id, $title, $body, session.user-id);
      if $ok {
        # The post was successful, let&#39;s show the user
        redirect &quot;/view/{$id}&quot;;
      } else {
        # The insert failed, let&#39;s show the user
        @errors.push(&#39;An error occurred while saving your post, please try again later&#39;);
        template &#39;post.crotmp&#39;, { :$title, :$body, :@errors };
      }
    }
  }</code></pre>
<p>Okay, now we have a working endpoint. When you fire up the app you can log in and you can create posts. So, what's left for this tiny demo? Let's make the <code>/view/:post-id</code> endpoint so we can see our posts. We'll take the format of the old bulletin boards where we show the body and then a threaded view of responses below it.</p>
<h4 id="hierarchal-post-view">Hierarchal Post View</h4>
<p>First let's get the easy part out of the way, in <code>templates/view.crotmp</code>:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/demo.css&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;&lt;.post.title&gt;&lt;/h2&gt;
    &lt;pre&gt;
      &lt;.post.body&gt;
    &lt;/pre&gt;
    &lt;@.levels:$l&gt;
      &lt;div&gt;
        &lt;&amp;HTML($l.level)&gt;&amp;gt; &lt;a href=&quot;/view/&lt;$l.id&gt;&quot;&gt;&lt;$l.title&gt;&lt;/a&gt;
      &lt;/div&gt;
    &lt;/@&gt;
    &lt;!-- if we&#39;re logged in then show a response form! !--&gt;
    &lt;?.logged-in&gt;
      &lt;br/&gt;
      &lt;br/&gt;
      &lt;@.response.errors: $err&gt;
        &lt;div&gt;Error: &lt;$err&gt;&lt;/div&gt;
      &lt;/@&gt;
      &lt;form method=&quot;POST&quot; action=&quot;/view/&lt;.post.id&gt;&quot;&gt;
        &lt;div&gt;&lt;input type=&quot;text&quot; name=&quot;title&quot; placeholder=&quot;Response Title&quot; value=&quot;&lt;.response.title&gt;&quot; /&gt;&lt;/div&gt;
        &lt;div&gt;&lt;textarea name=&quot;body&quot; cols=&quot;40&quot; rows=&quot;20&quot;&gt;&lt;.response.body&gt;&lt;/textarea&gt;&lt;/div&gt;
        &lt;div&gt;&lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt;&lt;/div&gt;
      &lt;/form&gt;
    &lt;/?&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Cool. Now if you're logged in you'll see a form to respond to whatever post you're viewing. We're wrapping our post body in <code>&lt;pre&gt;</code> because we're kicking it old school for this post. Let's add our routes in <code>lib/Demo/App.rakumod</code>:</p>
<pre class="raku"><code>  get -&gt; SessionVar \session, &#39;view&#39;, $id {
    # Build-post-hierarchy is doing some fun stuff to make our template code simple, more after the break
    my $data = build-post-hierarchy($id);
    if !$data {
      # If the post doesn&#39;t exist, go home
      redirect &#39;/&#39;;
    } else {
      template &#39;view.crotmp&#39;, {
        :post($data&lt;post&gt;),
        :levels($data&lt;levels&gt;),
        response =&gt; {title =&gt; &#39;&#39;, body =&gt; &#39;&#39;, parent =&gt; $id, errors =&gt; [] },
        logged-in =&gt; (session.user-id ?? True !! False),
      };
    }
  }

  post -&gt; SessionVar \session, &#39;view&#39;, $id {
    # Build-post-hierarchy is doing some fun stuff to make our template code simple, more after the break
    my $data = build-post-hierarchy($id);
    if !$data {
      redirect &#39;/&#39;;
    } else {
      request-body -&gt; (:$title, :$body) {
        my @errors;
        @errors.push(&#39;Title cannot be fewer than five characters&#39;) if $title.chars &lt;= 5;
        @errors.push(&#39;Post cannot be fewer than fifty characters&#39;) if $body.chars &lt;= 50;

        if @errors {
          template &#39;view.crotmp&#39;, {
            :post($data&lt;post&gt;),
            :levels($data&lt;levels&gt;),
            response =&gt; {title =&gt; $title, body =&gt; $body, parent =&gt; $id, errors =&gt; [] },
            logged-in =&gt; (session.user-id ?? True !! False),
            :@errors,
          };
        } else {
          my $rid = UUID.new.Str;
          my $ok = $db.query(&#39;insert into posts (id, title, body, author, parent) values (?, ?, ?, ?, ?);&#39;, $rid, $title, $body, session.user-id, $id);
          if $ok {
            # see-other is letting Cro know we need to do a `GET` request, otherwise we&#39;ll get stuck in an infinite loop
            redirect :see-other, &quot;/view/{$rid}&quot;;
          } else {
            @errors.push(&#39;An error occurred while saving your post, please try again later&#39;);
            template &#39;view.crotmp&#39;, {
              :post($data&lt;post&gt;),
              :levels($data&lt;levels&gt;),
              response =&gt; {title =&gt; $title, body =&gt; $body, parent =&gt; $id, errors =&gt; @errors },
              logged-in =&gt; (session.user-id ?? True !! False),
              :@errors,
            };
          }
        }
      }
    }
  }</code></pre>
<p>The <code>POST</code> route is very similar to the <code>post</code> route of the same method/name. It's doing essentially the same thing but adding a parent id to the post so that when we build the hierarchy we know exactly what to do. Let's take a look at that hierarchy builder (in <code>lib/Demo/App.rakumod</code>):</p>
<pre class="raku"><code># This sub is declared outside of our routes so we can use it in the GET/POST version
sub build-post-hierarchy(Str:D $id) {
  # Ensure the post exists prior to building the hierarchy
  my %post    = $db.query(&#39;select p.id, p.title, p.body, u.name from posts p left join users u on u.id = p.author where p.id = ?;&#39;, $id).hash;

  # This query looks a little complicated and requires SQLite &gt; 3.8.2
  # In `threads.*` we&#39;re following our top level to gather all nested sets of responses
  # In `threads.*` the query of `parents.*` is following whatever thread we&#39;re viewing until
  # we find a post with parent = null and this is our top level post
  my $sql     = q:to/EOSQL/;
with recursive threads(level,id,title,parent) as (
        select 0, id, title, parent from posts where id = (
          with recursive parents(id,parent) as (
        select id, parent from posts where id = ?
        union all
        select p.id, p.parent from posts p, parents where p.id = parents.parent
          ) select id from parents where parent is null
        )
        union all 
        select level+1, p.id, p.title, p.parent from posts p, threads where p.parent = threads.id
) select * from threads order by level, parent;
EOSQL

  # Return the problem to the handler
  if (%post&lt;id&gt;//&#39;&#39;) ne $id {
    return Nil
  }

  # This code makes it easy for templates to consume the posts as an ordered hierarchy
  # so that the template may just iterate an array
  my @threads = $db.query($sql, $id).hashes;
  my %indexes;
  my @levels;
  for @threads -&gt; $t {
    if %indexes{$t&lt;parent&gt;//&#39;&#39;} {
      @levels.splice(%indexes{$t&lt;parent&gt;}, 0, { id =&gt; $t&lt;id&gt;, title =&gt; $t&lt;title&gt;, (level =&gt; &#39;&amp;nbsp&#39; x $t&lt;level&gt; * 4) });
      for %indexes.keys -&gt; $k {
        %indexes{$k}++ if %indexes{$t&lt;parent&gt;} &lt; %indexes{$k};
      }
      %indexes{$t&lt;id&gt;} = %indexes{$t&lt;parent&gt;} + 1;
    } else {
      @levels.push({ id =&gt; $t&lt;id&gt;, title =&gt; $t&lt;title&gt;, level =&gt; (&#39;&amp;nbsp;&#39; x $t&lt;level&gt; * 4) });
      %indexes{$t&lt;id&gt;} = @levels.elems;
    }
  }
  return {:%post, :@levels};
}</code></pre>
<p>Whew. That's definitely a mouth full. Likely your use cases will be more straightforward but easy tutorials usually leave out some crucial bit and this is intended to show some complication.</p>
<p>All that's left at this point is making the homepage show top level posts so let's modify our home page's route (in <code>lib/Demo/App.rakumod</code>):</p>
<pre class="raku"><code>  get -&gt; SessionVar \session {
    template &#39;main.crotmp&#39;, {
      user      =&gt; session.user,
      # Add posts !
      posts     =&gt; $db.query(&#39;select id, title from posts where parent is null&#39;).hashes,
      logged-in =&gt; (session.user-id ?? True !! False),
    };
  }</code></pre>
<p>Our template to match (<code>templates/main.crotmp</code>):</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head /&gt;
  &lt;body&gt;
    &lt;div&gt;
    &lt;!.logged-in&gt;
      &lt;a href=&quot;/oauth&quot;&gt;Login&lt;/a&gt;
    &lt;/!&gt;
    &lt;?.logged-in&gt;
      Welcome, &lt;.user.name&gt; | &lt;a href=&quot;/post&quot;&gt;New Post&lt;/a&gt;
    &lt;/?&gt;
    &lt;/div&gt;
    &lt;h2&gt;Posts&lt;/h2&gt;
    &lt;@.posts:$p&gt;
    &lt;div&gt;
      ° &lt;a href=&quot;/view/&lt;$p.id&gt;&quot;&gt;&lt;$p.title&gt;&lt;/a&gt;
    &lt;/@&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Okay. That's it! You have a working cro app (or should)! Let's review what we've done in this app:</p>
<ol>
<li>Visitors can log in via OAuth</li>
<li>Anyone can view posts/responses</li>
<li>Registered users can create new posts and respond</li>
</ol>
<p>Seems like a lot of code for these three basic functions (and it is) but bulletin boards can get even more complicated very quickly.</p>
<p>This is part one of building a cro application end to end including deployment and next week the topic will be configuring apache to reverse proxy to our cro app and configuring systemd to ensure our app is available.</p>
<p>Note: the full code for this demo can be found <a href="https://github.com/tony-o/blog-cro">here</a></p>


    </div>
    <div id="footer">
      <h6>// social twitter:<a href="https://twitter.com/oynoto">@oynoto</a>, patreon:<a href="https://www.patreon.com/oynot">@oynot</a>, github:<a href="https://github.com/tony-o">tony-o</a></h6>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <script src="/s/hljs-raku.js"></script>
    <script>
      hljs.registerLanguage("raku", hljs_raku);
      (function(){
        languages = {}
        pres      = document.getElementsByTagName("pre");
        for(i = 0; i < hljs.listLanguages().length; i++){
          languages['language-' + hljs.listLanguages()[i]] = 1;
        }
        for(i = 0; i < pres.length; i++){
          pre = pres[i];
          cn  = 'language-plaintext';
          ls  = (pre.getAttribute("class") || 'plaintext').split(' ');
          for(j = 0; j < ls.length; j++){
            if(languages['language-' + ls[j]]){
              cn = 'language-' + ls[j];
              break;
            }
          }
          codes = pre.getElementsByTagName("code")
          for(j = 0; j < codes.length; j++){
            codes[j].setAttribute("class", (codes[j].getAttribute("class") + " hljs " + cn).trim())
          }
        }
        hljs.highlightAll();
      })();
    </script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FKJQZPJ2XK"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-FKJQZPJ2XK');
    </script>

  </body>
</html>
